"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard").default;
var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createFakeServer = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
var _xDataGridPro = require("@mui/x-data-grid-pro");
var _internals = require("@mui/x-data-grid/internals");
var _useDemoData = require("./useDemoData");
var _serverUtils = require("./serverUtils");
const DEFAULT_DATASET_OPTIONS = {
  dataSet: 'Commodity',
  rowLength: 100,
  maxColumns: 6
};
const createFakeServer = (dataSetOptions, serverOptions) => {
  const dataSetOptionsWithDefault = (0, _extends2.default)({}, DEFAULT_DATASET_OPTIONS, dataSetOptions);
  const serverOptionsWithDefault = (0, _extends2.default)({}, _serverUtils.DEFAULT_SERVER_OPTIONS, serverOptions);
  const columns = (0, _useDemoData.getColumnsFromOptions)(dataSetOptionsWithDefault);
  const initialState = (0, _useDemoData.getInitialState)(dataSetOptionsWithDefault, columns);
  const defaultColDef = (0, _xDataGridPro.getGridDefaultColumnTypes)();
  const columnsWithDefaultColDef = columns.map(column => (0, _extends2.default)({}, defaultColDef[column.type || 'string'], column));
  const useQuery = queryOptions => {
    const {
      data: {
        rows
      },
      loading: dataGenerationIsLoading
    } = (0, _useDemoData.useDemoData)(dataSetOptionsWithDefault);
    const queryOptionsRef = React.useRef(queryOptions);
    const [response, setResponse] = React.useState({
      pageInfo: {},
      rows: []
    });
    const [isLoading, setIsLoading] = React.useState(dataGenerationIsLoading);
    React.useEffect(() => {
      if (dataGenerationIsLoading) {
        // dataset is not ready
        return () => {};
      }
      queryOptionsRef.current = queryOptions;
      let active = true;
      setIsLoading(true);
      setResponse(prev => Object.keys(prev.pageInfo).length === 0 ? prev : (0, _extends2.default)({}, prev, {
        pageInfo: {}
      }));
      (async function fetchData() {
        const {
          returnedRows,
          nextCursor,
          totalRowCount,
          hasNextPage
        } = await (0, _serverUtils.loadServerRows)(rows, queryOptions, serverOptionsWithDefault, columnsWithDefaultColDef);
        if (!active) {
          return;
        }
        const newRep = {
          rows: returnedRows,
          pageInfo: {
            totalRowCount,
            nextCursor,
            hasNextPage,
            pageSize: returnedRows.length
          }
        };
        setResponse(prev => (0, _internals.isDeepEqual)(prev, newRep) ? prev : newRep);
        setIsLoading(false);
      })();
      return () => {
        active = false;
      };
    }, [dataGenerationIsLoading, queryOptions, rows]);

    // We use queryOptions pointer to be sure that isLoading===true as soon as the options change
    const effectShouldStart = queryOptionsRef.current !== queryOptions;
    return (0, _extends2.default)({
      isLoading: isLoading || effectShouldStart
    }, response);
  };
  return {
    columns,
    columnsWithDefaultColDef,
    initialState,
    useQuery
  };
};
exports.createFakeServer = createFakeServer;